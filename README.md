#
This project serves as a means to connect what we have learned in Object Oriented Programming to a classic video game. I wanted to be able to synthesize what I have learned in order to produce something similar to what I grew up playing in order to somewhat understand what goes through the mind of a programmer when in the designing process. Ultimately I ended up with twelve classes that are essentially split up into two sections: creation and management. The flow of the game is as follows; the client is asked for their name and given the opportunity to choose a pokemon out of three starters which they can rename if they so choose. Then, the client is prompted with a situation in which they can choose to fight, run, or attempt to catch a new wild pokemon. The situation with this new wild pokemon does not end until the client uses moves associated with their own starter pokemon to fight the wild pokemon, chooses to run away from the fight, or chooses to attempt to catch the wild pokemon. In the fighting scenario, each pokemon has a certain amount of health (HP) that determines how much damage they can take from each other. Each pokemon has a certain set of moves they can use that vary in damage. The client is prompted with what move to use and they simply type in which one and the pokemon executes that move while telling the client the damage it did. Every round of the fight the client is told the HP of their own pokemon and the enemy wild pokemon until one of the scenarios mentioned before is fulfilled. After this fight the client encounters the same scenario only with a different pokemon. Afterwards the client’s party of pokemon is healed up and they continue their journey to finally beat the gym leader. They have to fight these pokemon and are not able to run or attempt to catch the gym leader’s pokemon. The program ends with the success of this battle.

Creation:
Classes: Overall_Pokemon.java, PokeFactory.java, pokemon.java, user.java

First I wanted to create a single entity that would serve as the client. Since there would only be one of these at a time, I decided to go with the singleton pattern in user.java. This would limit the amount of users to one, which is what the game is designed to do, while being able to assign certain entities that I needed the user to be associated with. For example, the user needed a name from the client and also stored an unsized array of objects of type Overall_Pokemon and methods to interact with that list. So since we have only one user with only one party the game is ready to continue.

As mentioned before, we use Overall_Pokemon.java, PokeFactory.java, pokemon.java for actual creation of each pokemon. The base class is pokemon.java that serves as a builder design pattern due to the fact that the client can determine whether or not the pokemon can have a nickname. I believe the builder design program enabled me to meet this demand the best while keeping mandatory parameters enabled. Next, Overall_Pokemon of design pattern flyweight enables the use of the pokemon object to add new parameters to it while including methods to access and modify the original object. Parameters that vary and change overtime are included in this class to organize the object creation and modification. Parameters such as the moveset mentioned in the introduction were used. This was to maximize storage efficiency of all pokemon objects being created which is why we use the hashmap found in PokeFactory.java to manage this.


Management:
Classes: Battle.java, BattleOrig.java, Battletime.java, Command.java, CatchCommand.java, FightCommand.java, RunCommand.java

The other side to my program is the interaction between the Overall_Pokemon objects that are in the user’s possession and not in their possession. These functions serve as the interaction that gives the client the option to fight, run, or catch. I used the command design pattern in order to organize these user inputs and coordinate them as objects. Essentially, Command.java serves as the interface that CatchCommand, FightCommand, and RunCommand implement which individually calls the corresponding implementation within Battle.java. In order to keep the command system running until I determine it finished, I used a separate class BattleOrig that allowed the command system to keep running until one of the pokemon lost all health, the client caught the enemy pokemon, or the client chose to run away from the battle. BattleOrig uses the object created in BattleTime in order to call the commands listed above. 

Example process: main class creates an object under BattleOrig using two overall_pokemon objects and access to the user. When BattleMode() is called a while loop begins until one of three options mentioned before is broken. Client is prompted with fight, run, or catch and upon input, BattleOrig calls a BattleTime object that executes the function corresponding to the user input. This process allows easy organization flow while maintaining access to all objects needed for the game to happen.
